<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Luadocs for copas/timer.lua</title>
    <link rel="stylesheet" href="../../luadoc.css" type="text/css" />
    <!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
    <div id="product_logo"></div>
    <div id="product_name"><big><b></b></big></div>
    <div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h2>LuaDoc</h2>
<ul>
	
	<li><a href="../../index.html">Index</a></li>
	
</ul>


<!-- Module list -->



<!-- File list -->

<h2>Files</h2>
<ul>

	<li>
		<a href="../../files/copas/eventer.html">copas/eventer.lua</a>
	</li>

	<li><strong>copas/timer.lua</strong></li>
	
</ul>






</div> <!-- id="navigation" -->

<div id="content">

<h1>File "<code>copas/timer.lua</code>"</h1>


<p>Copas Timer is a module that adds a timer capability to the Copas scheduler. It provides the same base functions <code>step</code> and <code>loop</code> as Copas (it actually replaces them) except that it will also check for (and run) timers expiring and run background workers if there is no IO or timer to handle.<br/>&nbsp;<br/>To use the module it should be required as; <code>local copas = require("copas.timer")</code> because it returns the global <code>copas</code> table and not a separate timer table.<br/>&nbsp;<br/>There is a difference between the 2 background mechanisms provided; the timers run on the main loop, and hence should never yield. The workers run in their own thread (coroutine) and can be yielded if they take too long.<br/>&nbsp;<br/>The workers are dispatched from a rotating queue, so when a worker is up to run it will be removed from the queue, resumed, and (if not finished) added at the end of the queue again.<br/>&nbsp;<br/>Copas Timer is free software under the MIT/X11 license.</p>



<p>Copyright &copy; 2011-2013 Thijs Schreijer</p>


<p><small><b>Release:</b> Version 1.0, Timer module to extend Copas with a timer and worker capability</small></p>



<h2>Tables</h2>
<table class="table_list">

	<tr>
	<td class="name" nowrap><a href="#queueitem">queueitem</a></td>
	<td class="summary">Queue element to hold queued data in a worker queue.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#worker">worker</a></td>
	<td class="summary">Worker object.</td>
	</tr>

</table>



<h2>Functions</h2>
<table class="function_list">

    <tr>
    <td class="name" nowrap><a href="#copas.addworker">copas.addworker</a>&nbsp;(func, errhandler)</td>
    <td class="summary">Adds a worker thread.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.cancelall">copas.cancelall</a>&nbsp;()</td>
    <td class="summary">Cancels all currently armed timers.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.delayedexecutioner">copas.delayedexecutioner</a>&nbsp;(delay, func, ...)</td>
    <td class="summary">Calls a function delayed, after the specified amount of time.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.exitloop">copas.exitloop</a>&nbsp;(timeout, keeptimers)</td>
    <td class="summary">Instructs Copas to exit the loop.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.getworker">copas.getworker</a>&nbsp;(t)</td>
    <td class="summary">Returns a background worker table </td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.isexiting">copas.isexiting</a>&nbsp;()</td>
    <td class="summary">Indicator of the loop running or exiting.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.loop">copas.loop</a>&nbsp;(timeout, precision)</td>
    <td class="summary">Executes an endless loop handling Copas steps and timers  (it replaces the original <code>copas.loop()</code>).</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.newtimer">copas.newtimer</a>&nbsp;(f_arm, f_expire, f_cancel, recurring, f_error)</td>
    <td class="summary">Creates a new timer.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.removeworker">copas.removeworker</a>&nbsp;(t)</td>
    <td class="summary">Removes a worker thread </td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.step">copas.step</a>&nbsp;(timeout, precision)</td>
    <td class="summary">Executes a single Copas step followed by the execution of the first expired (if any) timer in the timers list (it replaces the original <code>copas.step()</code>) if there is no timer that expires then it will try to execute a worker step if available.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#copas.waitforcondition">copas.waitforcondition</a>&nbsp;(interval, timeout, condition, handler, ...)</td>
    <td class="summary">Executes a handler function after a specific condition has been met (non-blocking wait).</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#queueitem.cancel">queueitem.cancel</a>&nbsp;(self)</td>
    <td class="summary">Cancels the queueItem.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#queueitem.complete">queueitem.complete</a>&nbsp;(self)</td>
    <td class="summary">Completes the queueItem.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#timer.arm">timer.arm</a>&nbsp;(self, interval)</td>
    <td class="summary">Arms a previously created timer.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#timer.cancel">timer.cancel</a>&nbsp;(self)</td>
    <td class="summary">Cancels a previously armed timer.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#worker.pause">worker.pause</a>&nbsp;(self)</td>
    <td class="summary">Yields control in case of lengthy operations.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#worker.pop">worker.pop</a>&nbsp;(self)</td>
    <td class="summary">Retrieves data from the worker queue (and implicitly yields control).</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#worker.push">worker.push</a>&nbsp;(self, data)</td>
    <td class="summary">Adds data to the worker queue.</td>
    </tr>

</table>


<br/>
<br/>


<h2><a name="tables"></a>Tables</h2>
<dl class="table">

<dt><a name="queueitem"></a><strong>queueitem</strong></dt>
<dd>Queue element to hold queued data in a worker queue. Queue elements are created and returned by the the <code>worker:push()</code> method.


<h3>Fields</h3>
<ul>
	
	<li>
	  <code><em>cancelled</em></code>: flag; <code>true</code> when the element has been cancelled
	</li>
	
	<li>
	  <code><em>completed</em></code>: flag; <code>true</code> when the element has been completed or cancelled ('completed' is when the worker requests the next element by calling its <code>pop()</code> function
	</li>
	
	<li>
	  <code><em>worker</em></code>: The worker table for which this queue element has been enqueued.
	</li>
	
	<li>
	  <code><em>data</em></code>: the actual data
	</li>
	
</ul>





<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="files/copas/timer.html#queueitem.cancel">
		queueitem.cancel
	</a></li>
	
	<li><a href="files/copas/timer.html#queueitem.complete">
		queueitem.complete
	</a></li>
	
	<li><a href="files/copas/timer.html#worker.push">
		worker.push
	</a></li>
	
</ul>

</div>



</dd>


<dt><a name="worker"></a><strong>worker</strong></dt>
<dd>Worker object. These are created by the <code>addworker()</code> method.


<h3>Fields</h3>
<ul>
	
	<li>
	  <code><em>thread</em></code>: Holds the thread/coroutine for this worker
	</li>
	
	<li>
	  <code><em>errhandler</em></code>: Holds the errorhandler for this worker
	</li>
	
	<li>
	  <code><em>queue</em></code>: Holds the list of queue elements to be processed by the worker
	</li>
	
</ul>





<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="files/copas/timer.html#worker.push">
		worker.push
	</a></li>
	
	<li><a href="files/copas/timer.html#worker.pop">
		worker.pop
	</a></li>
	
	<li><a href="files/copas/timer.html#worker.pause">
		worker.pause
	</a></li>
	
	<li><a href="files/copas/timer.html#copas.addworker">
		copas.addworker
	</a></li>
	
</ul>

</div>



</dd>


</dl>



<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="copas.addworker"></a><strong>copas.addworker</strong>&nbsp;(func, errhandler)</dt>
<dd>
Adds a worker thread. The workers will be executed when there is no IO nor any expiring timer to run. The function will be started immediately upon creating the coroutine for the worker. Calling <code>worker:push(data)</code> on the returned worker table will enqueue data to be handled. The function can fetch data from the queue through <code>self:pop()</code> which will pop a new element from the workers queue. For lengthy operations where the code needs to yield without popping a new element from the queue, call <code>self:pause()</code>.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>func</em></code>: function to execute as the coroutine
	</li>
	
	<li>
	  <code><em>errhandler</em></code>: function to handle any errors returned
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
worker table

</div>



 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">local w = copas.addworker(function(queue)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- do some initializing here... will be run immediately upon<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- adding the worker<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while true do<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = queue:pop()    -- fetch data from queue, implictly yields the coroutine<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- handle the retrieved data here<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(data)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- do some lengthy stuff<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue:pause()         -- implicitly yields<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- do more lengthy stuff<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>-- enqueue data for the new worker<br/>w:push("here is some data")</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.removeworker">
		copas.removeworker
	</a></li>
	
	<li><a href="../../files/copas/timer.html#worker">
		worker
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.cancelall"></a><strong>copas.cancelall</strong>&nbsp;()</dt>
<dd>
Cancels all currently armed timers.











<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.exitloop">
		copas.exitloop
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.delayedexecutioner"></a><strong>copas.delayedexecutioner</strong>&nbsp;(delay, func, ...)</dt>
<dd>
Calls a function delayed, after the specified amount of time. An example use is a call that requires communications to be running already, but if you start the Copas loop, it basically blocks; classic chicken-egg. In this case use the <code>delayedexecutioner</code> to call the method in 0.5 seconds, just before starting the CopasTimer loop. Now when the method actually executes, communications will be online already. The internals use a timer, so it is executed on the main loop and should not be suspended by calling <code>yield()</code>.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>delay</em></code>: delay in seconds before calling the function
	</li>
	
	<li>
	  <code><em>func</em></code>: function to call
	</li>
	
	<li>
	  <code><em>...</em></code>: any arguments to be passed to the function
	</li>
	
</ul>







 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">local t = socket.gettime()<br/>copas.delayedexecutioner(5, function(txt)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(txt .. " and it was " .. socket.gettime() - t .. " to be precise.")<br/>&nbsp;&nbsp;&nbsp;&nbsp;end, "This should display in 5 seconds from now.")</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.newtimer">
		copas.newtimer
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.exitloop"></a><strong>copas.exitloop</strong>&nbsp;(timeout, keeptimers)</dt>
<dd>
Instructs Copas to exit the loop. It will wait for any background workers to complete their queue. If the <code>copas.eventer</code> is used then the timeout will only start after the <code>copas.events.loopstopping</code> event has been completely handled.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>timeout</em></code>: Timeout (in seconds) after which to forcefully exit the loop, abandoning any workers still running. <ul><li><code>nil</code> or negative: no timeout, continue running until all workers have emptied their queues</li> <li><code>&lt 0</code>: exit immediately after next loop iteration, do not wait for workers nor the <code>copas.events.loopstopping/loopstopped</code> events</li> to complete (timers will still be cancelled if set to do so)</ul>
	</li>
	
	<li>
	  <code><em>keeptimers</em></code>: (boolean) if <code>true</code> then the active timers will NOT be cancelled, otherwise <code>copas.cancelall()</code> will be called to properly cancel all running timers.
	</li>
	
</ul>










<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.loop">
		copas.loop
	</a></li>
	
	<li><a href="../../files/copas/timer.html#copas.isexiting">
		copas.isexiting
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.getworker"></a><strong>copas.getworker</strong>&nbsp;(t)</dt>
<dd>
Returns a background worker table


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>t</em></code>: thread (coroutine) to look up
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
the worker table (as earlier returned by <code>addworker()</code>) or <code>nil</code> if it wasn't found

</div>



 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">if copas.getworker(coroutine.running()) then<br/>&nbsp;&nbsp;&nbsp;&nbsp;print ("I'm running as a background worker")<br/>else<br/>&nbsp;&nbsp;&nbsp;&nbsp;print ("No background worker found, so I'm on my own")<br/>end</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.addworker">
		copas.addworker
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.isexiting"></a><strong>copas.isexiting</strong>&nbsp;()</dt>
<dd>
Indicator of the loop running or exiting.






<div>


<h3 class="inline-block">Return value:</h3>
<ul> <li><code>nil</code>: the loop is not running, </li> <li><code>false</code>: the loop is running, or </li> <li><code>true</code>: the loop is scheduled to stop</li></ul>

</div>



 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">if copas.isexiting() ~= nil then<br/>&nbsp;&nbsp;&nbsp;&nbsp;-- loop is currently running, make it exit after the worker queue is empty and cancel any timers<br/>&nbsp;&nbsp;&nbsp;&nbsp;copas.exitloop(nil, false)<br/>end</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.loop">
		copas.loop
	</a></li>
	
	<li><a href="../../files/copas/timer.html#copas.exitloop">
		copas.exitloop
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.loop"></a><strong>copas.loop</strong>&nbsp;(timeout, precision)</dt>
<dd>
Executes an endless loop handling Copas steps and timers  (it replaces the original <code>copas.loop()</code>). The loop can be terminated by calling <code>exitloop</code>.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>timeout</em></code>: time out (in seconds) to be used. The timer list will be checked at least every <code>timeout</code> period for expired timers. The actual interval will be between <code>0</code> and <code>timeout</code> based on the next timers expire time or worker threads being available. If not provided, it defaults to 5 seconds.
	</li>
	
	<li>
	  <code><em>precision</em></code>: the precision of the timer (in seconds). Whenever the timer list is checked for expired timers, a timer is considered expired when the exact expire time is in the past or up to <code>precision</code> seconds in the future. It defaults to 0.02 if not provided.
	</li>
	
</ul>










<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.step">
		copas.step
	</a></li>
	
	<li><a href="../../files/copas/timer.html#copas.exitloop">
		copas.exitloop
	</a></li>
	
	<li><a href="../../files/copas/timer.html#copas.isexiting">
		copas.isexiting
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.newtimer"></a><strong>copas.newtimer</strong>&nbsp;(f_arm, f_expire, f_cancel, recurring, f_error)</dt>
<dd>
Creates a new timer. After creating call the <code>arm</code> method of the new timer to actually schedule it. REMARK: the background workers run in their own thread (coroutine) and hence need to yield control when their operation takes too long, but the timers run on the main loop, and hence the callbacks should never yield, in those cases consider adding a worker through <code>copas.addworker()</code> from the timer callback.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>f_arm</em></code>: callback function to execute when the timer is armed
	</li>
	
	<li>
	  <code><em>f_expire</em></code>: callback function to execute when the timer expires
	</li>
	
	<li>
	  <code><em>f_cancel</em></code>: callback function to execute when the timer is cancelled
	</li>
	
	<li>
	  <code><em>recurring</em></code>: (boolean) should the timer automatically be re-armed with the same interval after it expired
	</li>
	
	<li>
	  <code><em>f_error</em></code>: callback function to execute when any of the other callbacks generates an error
	</li>
	
</ul>







 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">-- Create a new timer<br/>local t = copas.newtimer(nil, function () print("hello world") end, nil, false, nil)<br/>&nbsp;<br/>-- Create timer and arm it immediately, to be run in 5 seconds<br/>copas.newtimer(nil, function () print("hello world") end, nil, false, nil):arm(5)<br/>&nbsp;<br/>-- Create timer and arm it immediately, to be run now (function f is provide twice!) and again every 5 seconds<br/>local f = function () print("hello world") end<br/>copas.newtimer(f, f, nil, true, nil):arm(5)</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#timer.arm">
		timer.arm
	</a></li>
	
	<li><a href="../../files/copas/timer.html#timer.cancel">
		timer.cancel
	</a></li>
	
	<li><a href="../../files/copas/timer.html#copas.cancelall">
		copas.cancelall
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.removeworker"></a><strong>copas.removeworker</strong>&nbsp;(t)</dt>
<dd>
Removes a worker thread


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>t</em></code>: worker table (as returned by <code>copas.addworker()</code>), or actual thread/coroutine to be removed.
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
worker table or <code>nil</code> if it wasn't found

</div>






<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.addworker">
		copas.addworker
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.step"></a><strong>copas.step</strong>&nbsp;(timeout, precision)</dt>
<dd>
Executes a single Copas step followed by the execution of the first expired (if any) timer in the timers list (it replaces the original <code>copas.step()</code>) if there is no timer that expires then it will try to execute a worker step if available.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>timeout</em></code>: timeout value (in seconds) to pass to the Copas step handler
	</li>
	
	<li>
	  <code><em>precision</em></code>: see parameter <code>precision</code> at function <code>loop()</code>.
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
time in seconds until the next timer in the list expires, 0 if there is a worker waiting for execution, or <code>nil</code> if there is no timer nor any worker.

</div>






<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#copas.loop">
		copas.loop
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="copas.waitforcondition"></a><strong>copas.waitforcondition</strong>&nbsp;(interval, timeout, condition, handler, ...)</dt>
<dd>
Executes a handler function after a specific condition has been met (non-blocking wait). This is implemented using a timer, hence both the <code>condition()</code> and <code>handler()</code> functions run on the main thread and should never yield.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>interval</em></code>: interval (in seconds) for checking the condition
	</li>
	
	<li>
	  <code><em>timeout</em></code>: timeout value (in seconds) after which the operation fails (note that the <code>handler()</code> will still be called)
	</li>
	
	<li>
	  <code><em>condition</em></code>: a function that is called repeatedly. It will get the additional parameters specified to <code>waitforcondition()</code>. The function should return <code>true</code> or <code>false</code> depending on whether the condition was met.
	</li>
	
	<li>
	  <code><em>handler</em></code>: the handler function that will be executed. It will <strong>always</strong> be executed. The first argument to the handler will be <code>true</code> if the condition was met, or <code>false</code> if the operation timed-out, any additional parameters provided to <code>waitforcondition()</code> will be passed after that.
	</li>
	
	<li>
	  <code><em>...</em></code>: additional parameters passed on to both the <code>condition()</code> and <code>handler()</code> functions.
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
timer that verifies the condition.

</div>



 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">local count = 1<br/>function check(param)<br/>&nbsp;&nbsp;&nbsp;&nbsp;print("Check count ", count, ". Called using param = ", param)<br/>&nbsp;&nbsp;&nbsp;&nbsp;count = count + 1<br/>&nbsp;&nbsp;&nbsp;&nbsp;return (count == 10)<br/>end<br/>&nbsp<br/>function done(conditionmet, param)<br/>&nbsp;&nbsp;&nbsp;&nbsp;if conditionmet then<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("The condition was met when count reached ", count - 1,". Called using param = ", param)<br/>&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Failed, condition was not met. Called using param = ", param)<br/>&nbsp;&nbsp;&nbsp;&nbsp;end<br/>end<br/>&nbsp<br/>copas.waitforcondition(0.1, 5, check, done, "1234567890")</pre>

</div>




</dd>




<dt><a name="queueitem.cancel"></a><strong>queueitem.cancel</strong>&nbsp;(self)</dt>
<dd>
Cancels the queueItem. When cancelling both the <code>cancelled</code> and <code>completed</code> flag will be set. The cancel flag will prevent the data from being executed when it is being popped from the queue.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>self</em></code>: the queueitem
	</li>
	
</ul>










<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#queueitem">
		queueitem
	</a></li>
	
	<li><a href="../../files/copas/timer.html#worker.push">
		worker.push
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="queueitem.complete"></a><strong>queueitem.complete</strong>&nbsp;(self)</dt>
<dd>
Completes the queueItem. The <code>completed</code> flag will be set.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>self</em></code>: the queueitem
	</li>
	
</ul>










<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#queueitem">
		queueitem
	</a></li>
	
	<li><a href="../../files/copas/timer.html#worker.push">
		worker.push
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="timer.arm"></a><strong>timer.arm</strong>&nbsp;(self, interval)</dt>
<dd>
Arms a previously created timer. When <code>arm()</code> is called on an already armed timer then the timer will be rescheduled, the <code>cancel</code> handler will not be called in this case, but the <code>arm</code> handler will run.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>self</em></code>: timer table
	</li>
	
	<li>
	  <code><em>interval</em></code>: the interval after which the timer expires (in seconds). This must be set with the first call to <code>arm()</code> any additional calls will reuse the existing interval if no new interval is provided.
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
the timer <code>t</code>, which allows chaining creating/arming calls, see example.

</div>



 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">-- Create a new timer<br/>local f = function() print("hello world") end<br/>local t = copas.newtimer(nil, f, nil, false)<br/>t:arm(5)              -- arm it at 5 seconds<br/>-- which is equivalent to chaining the arm() call<br/>local t = copas.newtimer(nil, f, nil, false):arm(5)</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#timer.cancel">
		timer.cancel
	</a></li>
	
	<li><a href="../../files/copas/timer.html#copas.newtimer">
		copas.newtimer
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="timer.cancel"></a><strong>timer.cancel</strong>&nbsp;(self)</dt>
<dd>
Cancels a previously armed timer. This will run the <code>cancel</code> handler provided when creating the timer.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>self</em></code>: timer table
	</li>
	
</ul>







 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">-- Create a new timer<br/>local t = copas.newtimer(nil, function () print("hello world") end, nil, false)<br/>t:arm(5)              -- arm it at 5 seconds<br/>t:cancel()            -- cancel it again</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#timer.arm">
		timer.arm
	</a></li>
	
	<li><a href="../../files/copas/timer.html#copas.newtimer">
		copas.newtimer
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="worker.pause"></a><strong>worker.pause</strong>&nbsp;(self)</dt>
<dd>
Yields control in case of lengthy operations. Similar to <code>pop()</code> except that this method does not pop a new element from the worker queue.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>self</em></code>: The worker table
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
<code>true</code>

</div>






<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#worker">
		worker
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="worker.pop"></a><strong>worker.pop</strong>&nbsp;(self)</dt>
<dd>
Retrieves data from the worker queue (and implicitly yields control). Note that this method implicitly yields the coroutine until new data has been pushed in the worker queue.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>self</em></code>: The worker table
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
data field of the next queueitem popped from the queue

</div>






<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#worker">
		worker
	</a></li>
	
	<li><a href="../../files/copas/timer.html#queueitem">
		queueitem
	</a></li>
	
</ul>

</div>


</dd>




<dt><a name="worker.push"></a><strong>worker.push</strong>&nbsp;(self, data)</dt>
<dd>
Adds data to the worker queue.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  <code><em>self</em></code>: The worker table
	</li>
	
	<li>
	  <code><em>data</em></code>: Data to be added to the queue of the worker
	</li>
	
</ul>





<div>


<h3 class="inline-block">Return value:</h3>
queueitem that was added to the worker queue

</div>



 
<div>

<h3 class="inline-block">Example:</h3>
<pre class="example">local w = copas.addworker(myfunc)<br/>worker:push("some data")</pre>

</div>



<div>

<h3>See also:</h3>
<ul>
	
	<li><a href="../../files/copas/timer.html#worker">
		worker
	</a></li>
	
	<li><a href="../../files/copas/timer.html#queueitem">
		queueitem
	</a></li>
	
</ul>

</div>


</dd>


</dl>


</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
    <p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->
</body>
</html>
