<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title> Luadocs Index</title>
    <link rel="stylesheet" href="luadoc.css" type="text/css" />
    <!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
    <div id="product_logo"></div>
    <div id="product_name"><big><b></b></big></div>
    <div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h2>LuaDoc</h2>
<ul>
	
	<li><strong>Index</strong></li>
	
</ul>


<!-- Module list -->



<!-- File list -->

<h2>Files</h2>
<ul>

	<li>
		<a href="files/copas/eventer.html">copas/eventer.lua</a>
	</li>

	<li>
		<a href="files/copas/timer.html">copas/timer.lua</a>
	</li>

</ul>






</div> <!-- id="navigation" -->

<div id="content">


<div id="readme">
<br/><h1>Copas Timer</h1><br/><p>Copas Timer is free software under the MIT/X11 license. <br/><br/>Copyright 2011-2013 Thijs Schreijer</p><br/><br/><p><a href="http://tieske.github.com/CopasTimer/">Documentation</a> and <a href="http://github.com/Tieske/CopasTimer">sourcecode</a> are on GitHub</p><br/><br/><h2>Purpose</h2><br/><p>Copas Timer is an add on module for the Copas socket scheduler. Copas Timer implements background workers and timers along side the sockets. As an optional component the eventer module is available which allows for event-driven code. The events are being run as background workers in the scheduler.</p><br/><br/><p>Note: this is still all coroutine based, so it is not non-blocking asynchroneous!</p><br/><br/><h2>Usage</h2><br/><p>Copas Timer integrates into the Copas module, so there is no separate module table for it. When you <code>require("copas.timer")</code> it will return the modified Copas module table.</p><br/><br/><p>Below some simple examples for using the Copas Timer functionalities.</p><br/><h3>Timers</h3><br/><p>The timers are created using callback functions;</p><br/><br/><p>```lua<br/>local copas = require("copas.timer")</p><br/><br/><p>-- define timer callbacks<br/>local arm<em>cb = nil<br/>local expire</em>cb = function() print("executing the timer") end<br/>local cancel_cb = nil<br/>-- define timer parameters<br/>local recurring = true<br/>local interval = 5  --> in seconds</p><br/><br/><p>local t = copas.newtimer(arm<em>cb, expire</em>cb, cancel_cb, recurring):arm(interval)</p><br/><br/><p>-- add some sockets here</p><br/><br/><p>copas.loop()    --> start the scheduler and execute the timers</p><br/><br/><p>````</p><br/><h3>Workers</h3><br/><p>Workers are created as coroutines from functions. Each worker gets its own queue of data to work on, and they will only run when data is available.</p><br/><br/><p>```lua<br/>local copas = require("copas.timer")</p><br/><br/><p>local w = copas.addworker(function(queue)</p><br/><pre><code>-- do some initializing here... will be run immediately upon<br/>-- adding the worker<br/>while true do<br/>&nbsp;&nbsp;data = queue:pop()    -- fetch data from queue, implicitly yields the coroutine<br/>&nbsp;&nbsp;-- handle the retrieved data here<br/>&nbsp;&nbsp;print(data)<br/>&nbsp;&nbsp;-- do some lengthy stuff<br/>&nbsp;&nbsp;queue:pause()         -- implicitly yields, without fetching new data<br/>&nbsp;&nbsp;-- do more lengthy stuff<br/>end<br/></code></pre><br/><p>  end)</p><br/><br/><p>-- enqueue data for the new worker<br/>w:push("here is some data")   </p><br/><br/><p>-- add some sockets here</p><br/><br/><p>copas.loop()<br/>````</p><br/><br/><h3>Events</h3><br/><p>The eventer module adds event capabilities to copas. The eventhandlers run as workers and process<br/>event data from their worker queues.</p><br/><br/><p>Copas itself will also be generating events once the eventer module is used;<br/>```lua<br/>local copas = require("copas.timer")<br/>require("copas.eventer")   -- will be installed inside the global copas table; copas.eventer</p><br/><br/><p>local my<em>app = {<br/>&nbsp;&nbsp;before</em>start = function(eventqueue)</p><br/><pre><code>while true do<br/>&nbsp;&nbsp;local event = eventqueue:pop()<br/>&nbsp;&nbsp;local self = event.client<br/><br/>&nbsp;&nbsp;-- initialize stuff and create some sockets here...<br/><br/>end<br/></code></pre><br/><p>  end,</p><br/><br/><p>  after_start = function(eventqueue)</p><br/><pre><code>while true do<br/>&nbsp;&nbsp;local event = eventqueue:pop()<br/>&nbsp;&nbsp;local self = event.client<br/><br/>&nbsp;&nbsp;-- do some stuff<br/><br/>end<br/></code></pre><br/><p>  end,<br/>}</p><br/><br/><p>copas:subscribe(my<em>app, my</em>app.before<em>start, copas.events.loopstarting)<br/>copas:subscribe(my</em>app, my<em>app.before</em>start, copas.events.loopstarted)</p><br/><br/><p>copas.loop()<br/>````</p><br/><br/><p>Adding event capabilities to your own object is easy;</p><br/><br/><p>```lua<br/>local copas = require("copas.timer")<br/>require("copas.eventer")   -- will be installed inside the global copas table; copas.eventer</p><br/><br/><p>-- create a module table and enable it with 4 events;<br/>local my<em>module = {}<br/>copas.eventer.decorate(my</em>module, {"start", "txerror", "rxerror", "stop"})</p><br/><br/><p>my_module.start = function(self)</p><br/><pre><code>-- lets dispatch our start event here<br/>self:dispatch(self.events.start, "start data 1", "start data 2")<br/></code></pre><br/><p>end</p><br/><br/><p>return my_module<br/>````</p><br/><br/><br/><h2>Changelog;</h2><br/><h3>xx-xxx-2013; release 1.0</h3><br/><p>- background workers have been completely revised to work as coroutines instead of callbacks. This also reflects in the <code>eventer</code> module, where <br/>event handlers must now be setup as coroutines and get their event data from a queue.</p><br/><br/><h3>07-Mar-2013; release 0.4.3</h3><br/><p>- <code>eventer.decorate()</code> function now protects access to <code>events</code> table so invalid events throw an error<br/>- fixed bug in timer errorhandler function</p><br/><br/><h3>04-Jun-2012; release 0.4.2</h3><br/><p>- fixed undefined behaviour when arming an already armed timer<br/>- removed default 1 second interval, now throws an error if the first call to <code>arm()</code> does not provide an interval.<br/>- bugfix, worker could not remove itself from the worker queue<br/>- added method <code>copas.waitforcondition()</code> to the timer module</p><br/><br/><h3>07-Nov-2011; release 0.4.1</h3><br/><p>- bugfix, timer could not be cancelled from its own handler.<br/>- bugfix, worker completed elswhere is no longer resumed.<br/>- changed <code>exitloop()</code> and <code>isexiting()</code> members, see docs for use (this is breaking!)<br/>- added an optional eventer module that fires events as background tasks<br/>- restructured files, no longer 'copastimer.lua' but now 'copas/timer.lua' (and 'copas/eventer.lua'). (this is breaking!)</p><br/><br/><h3>24-Oct-2011; Initial release 0.4.0</h3><br/><br/><hr/><br/><br/>
</div>







<h2>Files</h2>
<table class="file_list">
<!--<tr><td colspan="2">Files</td></tr>-->

    <tr>
        <td class="name"><a href="files/copas/eventer.html">copas/eventer.lua</a></td>
        <td class="summary"></td>
    </tr>

    <tr>
        <td class="name"><a href="files/copas/timer.html">copas/timer.lua</a></td>
        <td class="summary"></td>
    </tr>

</table>


</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
    <p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->
</body>
</html>
