<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>CopasTimer</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>CopasTimer</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>timer</strong></li>
</ul>
<h2>Topics</h2>
<ul class="nowrap">
  <li><a href="topics/readme.md.html">readme.md</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>timer</code></h1>

<p>Copas Timer is a module that adds a timer capability to the Copas scheduler.</p>
<p> It provides the same base functions <code>step</code> and <code>loop</code>
 as Copas (it actually replaces them) except that it will also check for (and
 run) timers expiring and run background workers if there is no IO or timer to
 handle.<br/>
 <br/>To use the module it should be required as; <code>local copas =
 require("copas.timer")</code> because it returns the global <code>copas</code>
 table and not a separate timer table.<br/>
 <br/>There is a difference between the 2 background mechanisms provided; the
 timers run on the main loop, and hence should never yield. The workers run in
 their own thread (coroutine) and can be yielded if they take too long.<br/>
 <br/>The workers are dispatched from a rotating queue, so when a worker is up to run
 it will be removed from the queue, resumed, and (if not finished) added at the end
 of the queue again.<br/>
 <br/>Copas Timer is free software under the MIT/X11 license.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Release</strong>: Version 1.0, Timer module to extend Copas with a timer and worker capability</li>
        <li><strong>Copyright</strong>: 2011-2013 Thijs Schreijer</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#arm">arm (self, interval)</a></td>
	<td class="summary">Arms a previously created timer.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cancel">cancel (self)</a></td>
	<td class="summary">Cancels a previously armed timer.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.addworker">copas.addworker (func, errhandler)</a></td>
	<td class="summary">Adds a worker thread.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.cancelall">copas.cancelall ()</a></td>
	<td class="summary">Cancels all currently armed timers.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.delayedexecutioner">copas.delayedexecutioner (delay, func, ...)</a></td>
	<td class="summary">Calls a function delayed, after the specified amount of time.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.exitloop">copas.exitloop (timeout, keeptimers)</a></td>
	<td class="summary">Instructs Copas to exit the loop.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.getworker">copas.getworker (t)</a></td>
	<td class="summary">Returns a background worker table</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.isexiting">copas.isexiting ()</a></td>
	<td class="summary">Indicator of the loop running or exiting.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.loop">copas.loop (timeout, precision)</a></td>
	<td class="summary">Executes an endless loop handling Copas steps and timers  (it replaces the original <code>copas.loop()</code>).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.newtimer">copas.newtimer (f_arm, f_expire, f_cancel, recurring, f_error)</a></td>
	<td class="summary">Creates a new timer.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.removeworker">copas.removeworker (t)</a></td>
	<td class="summary">Removes a worker thread</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.step">copas.step (timeout, precision)</a></td>
	<td class="summary">Executes a single Copas step followed by the execution of the first expired
 (if any) timer in the timers list (it replaces the original <code>copas.step()</code>)
 if there is no timer that expires then it will try to execute a worker step if available.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#copas.waitforcondition">copas.waitforcondition (interval, timeout, condition, handler, ...)</a></td>
	<td class="summary">Executes a handler function after a specific condition has been met
 (non-blocking wait).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#queueitem.complete">queueitem.complete (self)</a></td>
	<td class="summary">Completes the queueItem.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#worker.pause">worker.pause (self)</a></td>
	<td class="summary">Yields control in case of lengthy operations.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#worker.pop">worker.pop (self)</a></td>
	<td class="summary">Retrieves data from the worker queue (and implicitly yields control).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#worker.push">worker.push (self, data)</a></td>
	<td class="summary">Adds data to the worker queue.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "arm"></a>
    <strong>arm (self, interval)</strong>
    </dt>
    <dd>
    Arms a previously created timer.  When <code>arm()</code> is called on an already
 armed timer then the timer will be rescheduled, the <code>cancel</code> handler
 will not be called in this case, but the <code>arm</code> handler will run.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         timer table
        </li>
        <li><span class="parameter">interval</span>
         the interval after which the timer expires (in seconds). This must
 be set with the first call to <code>arm()</code> any additional calls will reuse
 the existing interval if no new interval is provided.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the timer <code>t</code>, which allows chaining creating/arming calls, see example.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#cancel">timer.cancel</a></li>
         <li><a href="index.html#copas.newtimer">copas.newtimer</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="comment">-- Create a new timer
</span> <span class="keyword">local</span> f = <span class="keyword">function</span>() <span class="global">print</span>(<span class="string">"hello world"</span>) <span class="keyword">end</span>
 <span class="keyword">local</span> t = copas.newtimer(<span class="keyword">nil</span>, f, <span class="keyword">nil</span>, <span class="keyword">false</span>)
 t:arm(<span class="number">5</span>)              <span class="comment">-- arm it at 5 seconds
</span> <span class="comment">-- which is equivalent to chaining the arm() call
</span> <span class="keyword">local</span> t = copas.newtimer(<span class="keyword">nil</span>, f, <span class="keyword">nil</span>, <span class="keyword">false</span>):arm(<span class="number">5</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "cancel"></a>
    <strong>cancel (self)</strong>
    </dt>
    <dd>
    Cancels a previously armed timer.  This will run the <code>cancel</code> handler
 provided when creating the timer.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         timer table
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#arm">timer.arm</a></li>
         <li><a href="index.html#copas.newtimer">copas.newtimer</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="comment">-- Create a new timer
</span> <span class="keyword">local</span> t = copas.newtimer(<span class="keyword">nil</span>, <span class="keyword">function</span> () <span class="global">print</span>(<span class="string">"hello world"</span>) <span class="keyword">end</span>, <span class="keyword">nil</span>, <span class="keyword">false</span>)
 t:arm(<span class="number">5</span>)              <span class="comment">-- arm it at 5 seconds
</span> t:cancel()            -- cancel it again</pre>
    </ul>

</dd>
    <dt>
    <a name = "copas.addworker"></a>
    <strong>copas.addworker (func, errhandler)</strong>
    </dt>
    <dd>
    Adds a worker thread.  The workers will be executed when there is no IO nor
 any expiring timer to run. The function will be started immediately upon
 creating the coroutine for the worker. Calling <code>worker:push(data)</code> on
 the returned worker table will enqueue data to be handled. The function can
 fetch data from the queue through <code>self:pop()</code> which will
 pop a new element from the workers queue. For lengthy operations where the code needs
 to yield without popping a new element from the queue, call <code>self:pause()</code>.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">func</span>
         function to execute as the coroutine
        </li>
        <li><span class="parameter">errhandler</span>
         function to handle any errors returned (must be a function
 taking 2 arguments; 1 - coroutine generating the error, 2 - returned error)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        worker table
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#copas.removeworker">copas.removeworker</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="keyword">local</span> w = copas.addworker(<span class="keyword">function</span>(queue)
         <span class="comment">-- do some initializing here... will be run immediately upon
</span>         <span class="comment">-- adding the worker
</span>         <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
             data = queue:pop()    <span class="comment">-- fetch data from queue, implictly yields the coroutine
</span>             <span class="comment">-- handle the retrieved data here
</span>             <span class="global">print</span>(data)
             <span class="comment">-- do some lengthy stuff
</span>             queue:pause()         <span class="comment">-- implicitly yields
</span>             <span class="comment">-- do more lengthy stuff
</span>         <span class="keyword">end</span>
     <span class="keyword">end</span>)
 <span class="comment">-- enqueue data for the new worker
</span> w:push(<span class="string">"here is some data"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "copas.cancelall"></a>
    <strong>copas.cancelall ()</strong>
    </dt>
    <dd>
    Cancels all currently armed timers.




    <h3>See also:</h3>
    <ul>
         <a href="index.html#copas.exitloop">copas.exitloop</a>
    </ul>


</dd>
    <dt>
    <a name = "copas.delayedexecutioner"></a>
    <strong>copas.delayedexecutioner (delay, func, ...)</strong>
    </dt>
    <dd>
    Calls a function delayed, after the specified amount of time.
 An example use is a call that requires communications to be running already,
 but if you start the Copas loop, it basically blocks; classic chicken-egg. In this case use the
 <code>delayedexecutioner</code> to call the method in 0.5 seconds, just before
 starting the CopasTimer loop. Now when the method actually executes, communications
 will be online already. The internals use a timer, so it is executed on the main
 loop and should not be suspended by calling <code>yield()</code>.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">delay</span>
         delay in seconds before calling the function
        </li>
        <li><span class="parameter">func</span>
         function to call
        </li>
        <li><span class="parameter">...</span>
         any arguments to be passed to the function
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="index.html#copas.newtimer">copas.newtimer</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="keyword">local</span> t = socket.gettime()
 copas.delayedexecutioner(<span class="number">5</span>, <span class="keyword">function</span>(txt)
         <span class="global">print</span>(txt .. <span class="string">" and it was "</span> .. socket.gettime() - t .. <span class="string">" to be precise."</span>)
     <span class="keyword">end</span>, <span class="string">"This should display in 5 seconds from now."</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "copas.exitloop"></a>
    <strong>copas.exitloop (timeout, keeptimers)</strong>
    </dt>
    <dd>
    Instructs Copas to exit the loop.  It will wait for any background workers to complete their queue.
 If the <code>copas.eventer</code> is used then the timeout will only start after the
 <code>copas.events.loopstopping</code> event has been completely handled.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         Timeout (in seconds) after which to forcefully exit the loop,
 abandoning any workers still running.
 <ul><li><code>nil</code> or negative: no timeout, continue running until all workers have emptied their queues</li>
 <li><code>&amp;lt 0</code>: exit immediately after next loop iteration, do not
 wait for workers nor the <code>copas.events.loopstopping/loopstopped</code> events</li> to complete
 (timers will still be cancelled if set to do so)</ul>
        </li>
        <li><span class="parameter">keeptimers</span>
         (boolean) if <code>true</code> then the active timers will NOT be cancelled, otherwise
 <code>copas.cancelall()</code> will be called to properly cancel all running timers.
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#copas.loop">copas.loop</a></li>
         <li><a href="index.html#copas.isexiting">copas.isexiting</a></li>
    </ul>


</dd>
    <dt>
    <a name = "copas.getworker"></a>
    <strong>copas.getworker (t)</strong>
    </dt>
    <dd>
    Returns a background worker table

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
         thread (coroutine) to look up
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the worker table (as earlier returned by <code>addworker()</code>)
 or <code>nil</code> if it wasn't found
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#copas.addworker">copas.addworker</a>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="keyword">if</span> copas.getworker(<span class="global">coroutine</span>.running()) <span class="keyword">then</span>
     <span class="global">print</span> (<span class="string">"I'm running as a background worker"</span>)
 <span class="keyword">else</span>
     <span class="global">print</span> (<span class="string">"No background worker found, so I'm on my own"</span>)
 <span class="keyword">end</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "copas.isexiting"></a>
    <strong>copas.isexiting ()</strong>
    </dt>
    <dd>
    Indicator of the loop running or exiting.


    <h3>Returns:</h3>
    <ol>

         <ul>
 <li><code>nil</code>: the loop is not running, </li>
 <li><code>false</code>: the loop is running, or </li>
 <li><code>true</code>: the loop is scheduled to stop</li></ul>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#copas.loop">copas.loop</a></li>
         <li><a href="index.html#copas.exitloop">copas.exitloop</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="keyword">if</span> copas.isexiting() ~= <span class="keyword">nil</span> <span class="keyword">then</span>
     <span class="comment">-- loop is currently running, make it exit after the worker queue is empty and cancel any timers
</span>     copas.exitloop(<span class="keyword">nil</span>, <span class="keyword">false</span>)
 <span class="keyword">end</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "copas.loop"></a>
    <strong>copas.loop (timeout, precision)</strong>
    </dt>
    <dd>
    Executes an endless loop handling Copas steps and timers  (it replaces the original <code>copas.loop()</code>).
 The loop can be terminated by calling <code>exitloop</code>.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         time out (in seconds) to be used. The timer list
 will be checked at least every <code>timeout</code> period for expired timers. The
 actual interval will be between <code>0</code> and <code>timeout</code> based on the next
 timers expire time or worker threads being available. If not provided, it defaults to 5 seconds.
        </li>
        <li><span class="parameter">precision</span>
         the precision of the timer (in seconds). Whenever the timer
 list is checked for expired timers, a timer is considered expired when the exact
 expire time is in the past or up to <code>precision</code> seconds in the future.
 It defaults to 0.02 if not provided.
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#copas.step">copas.step</a></li>
         <li><a href="index.html#copas.exitloop">copas.exitloop</a></li>
         <li><a href="index.html#copas.isexiting">copas.isexiting</a></li>
    </ul>


</dd>
    <dt>
    <a name = "copas.newtimer"></a>
    <strong>copas.newtimer (f_arm, f_expire, f_cancel, recurring, f_error)</strong>
    </dt>
    <dd>
    Creates a new timer.
 After creating call the <code>arm</code> method of the new timer to actually
 schedule it. REMARK: the background workers run in their own thread (coroutine)
 and hence need to yield control when their operation takes too long, but
 the timers run on the main loop, and hence the callbacks should never
 yield, in those cases consider adding a worker through
 <code>copas.addworker()</code> from the timer callback.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">f_arm</span>
         callback function to execute when the timer is armed
        </li>
        <li><span class="parameter">f_expire</span>
         callback function to execute when the timer expires
        </li>
        <li><span class="parameter">f_cancel</span>
         callback function to execute when the timer is cancelled
        </li>
        <li><span class="parameter">recurring</span>
         (boolean) should the timer automatically be re-armed with
 the same interval after it expired
        </li>
        <li><span class="parameter">f_error</span>
         callback function to execute (in a <code>xpcall()</code> call)
 when any of the other callbacks generates an error
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#arm">timer.arm</a></li>
         <li><a href="index.html#cancel">timer.cancel</a></li>
         <li><a href="index.html#copas.cancelall">copas.cancelall</a></li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="comment">-- Create a new timer
</span> <span class="keyword">local</span> t = copas.newtimer(<span class="keyword">nil</span>, <span class="keyword">function</span> () <span class="global">print</span>(<span class="string">"hello world"</span>) <span class="keyword">end</span>, <span class="keyword">nil</span>, <span class="keyword">false</span>, <span class="keyword">nil</span>)
 &amp;nbsp;
 <span class="comment">-- Create timer and arm it immediately, to be run in 5 seconds
</span> copas.newtimer(<span class="keyword">nil</span>, <span class="keyword">function</span> () <span class="global">print</span>(<span class="string">"hello world"</span>) <span class="keyword">end</span>, <span class="keyword">nil</span>, <span class="keyword">false</span>, <span class="keyword">nil</span>):arm(<span class="number">5</span>)
 &amp;nbsp;
 <span class="comment">-- Create timer and arm it immediately, to be run now (function f is provide twice!) and again every 5 seconds
</span> <span class="keyword">local</span> f = <span class="keyword">function</span> () <span class="global">print</span>(<span class="string">"hello world"</span>) <span class="keyword">end</span>
 copas.newtimer(f, f, <span class="keyword">nil</span>, <span class="keyword">true</span>, <span class="keyword">nil</span>):arm(<span class="number">5</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "copas.removeworker"></a>
    <strong>copas.removeworker (t)</strong>
    </dt>
    <dd>
    Removes a worker thread

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
         worker table (as returned by <code>copas.addworker()</code>), or actual thread/coroutine
 to be removed.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        worker table or <code>nil</code> if it wasn't found
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#copas.addworker">copas.addworker</a>
    </ul>


</dd>
    <dt>
    <a name = "copas.step"></a>
    <strong>copas.step (timeout, precision)</strong>
    </dt>
    <dd>
    Executes a single Copas step followed by the execution of the first expired
 (if any) timer in the timers list (it replaces the original <code>copas.step()</code>)
 if there is no timer that expires then it will try to execute a worker step if available.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         timeout value (in seconds) to pass to the Copas step handler
        </li>
        <li><span class="parameter">precision</span>
         see parameter <code>precision</code> at function <code>loop()</code>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        time in seconds until the next timer in the list expires, 0 if there is a worker
 waiting for execution, or <code>nil</code> if there is no timer nor any worker.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#copas.loop">copas.loop</a>
    </ul>


</dd>
    <dt>
    <a name = "copas.waitforcondition"></a>
    <strong>copas.waitforcondition (interval, timeout, condition, handler, ...)</strong>
    </dt>
    <dd>
    Executes a handler function after a specific condition has been met
 (non-blocking wait).  This is implemented using a timer, hence both the
 <code>condition()</code> and <code>handler()</code> functions run on the main
 thread and should never yield.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">interval</span>
         interval (in seconds) for checking the condition
        </li>
        <li><span class="parameter">timeout</span>
         timeout value (in seconds) after which the operation fails
 (note that the <code>handler()</code> will still be called)
        </li>
        <li><span class="parameter">condition</span>
         a function that is called repeatedly. It will get the
 additional parameters specified to <code>waitforcondition()</code>. The
 function should return <code>true</code> or <code>false</code> depending on
 whether the condition was met.
        </li>
        <li><span class="parameter">handler</span>
         the handler function that will be executed. It will
 <strong>always</strong> be executed. The first argument to the handler will
 be <code>true</code> if the condition was met, or <code>false</code> if the
 operation timed-out, any additional parameters provided to
 <code>waitforcondition()</code> will be passed after that.
        </li>
        <li><span class="parameter">...</span>
         additional parameters passed on to both the <code>condition()</code>
 and <code>handler()</code> functions.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        timer that verifies the condition.
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="keyword">local</span> count = <span class="number">1</span>
 <span class="keyword">function</span> check(param)
     <span class="global">print</span>(<span class="string">"Check count "</span>, count, <span class="string">". Called using param = "</span>, param)
     count = count + <span class="number">1</span>
     <span class="keyword">return</span> (count == <span class="number">10</span>)
 <span class="keyword">end</span>
 &amp;nbsp
 <span class="keyword">function</span> done(conditionmet, param)
     <span class="keyword">if</span> conditionmet <span class="keyword">then</span>
         <span class="global">print</span>(<span class="string">"The condition was met when count reached "</span>, count - <span class="number">1</span>,<span class="string">". Called using param = "</span>, param)
     <span class="keyword">else</span>
         <span class="global">print</span>(<span class="string">"Failed, condition was not met. Called using param = "</span>, param)
     <span class="keyword">end</span>
 <span class="keyword">end</span>
 &amp;nbsp
 copas.waitforcondition(<span class="number">0.1</span>, <span class="number">5</span>, check, done, <span class="string">"1234567890"</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "queueitem.complete"></a>
    <strong>queueitem.complete (self)</strong>
    </dt>
    <dd>
    Completes the queueItem.
 The <code>completed</code> flag will be set.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         the queueitem
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="index.html#worker.push">worker.push</a>
    </ul>


</dd>
    <dt>
    <a name = "worker.pause"></a>
    <strong>worker.pause (self)</strong>
    </dt>
    <dd>
    Yields control in case of lengthy operations.  Similar to <code>pop()</code> except
 that this method does not pop a new element from the worker queue.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         The worker table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <code>true</code>
    </ol>


    <h3>See also:</h3>
    <ul>
    </ul>


</dd>
    <dt>
    <a name = "worker.pop"></a>
    <strong>worker.pop (self)</strong>
    </dt>
    <dd>
    Retrieves data from the worker queue (and implicitly yields control).  Note that this method
 implicitly yields the coroutine until new data has been pushed in the worker queue.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         The worker table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        data field of the next queueitem popped from the queue
    </ol>


    <h3>See also:</h3>
    <ul>
    </ul>


</dd>
    <dt>
    <a name = "worker.push"></a>
    <strong>worker.push (self, data)</strong>
    </dt>
    <dd>
    Adds data to the worker queue.  If the worker has died, it will return an error
 and nothing will be enqueued.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>
         The worker table
        </li>
        <li><span class="parameter">data</span>
         Data to be added to the queue of the worker
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        queueitem that was added to the worker queue, or <code>nil</code> and error message
    </ol>


    <h3>See also:</h3>
    <ul>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> w = copas.addworker(myfunc)
 worker:push(<span class="string">"some data"</span>)</pre>
    </ul>

</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
